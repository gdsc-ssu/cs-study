
# 운영체제의 메모리 관리

## 단일 프로그래밍(Uni-programming)

- 운영체제 외 하나의 사용자 프로그램만 저장하는 방식, **한번에 오직 하나의 프로그램만 주기억장치에 저장해 실행**할 수 있다.
- 사용자 프로그램을 메모리 주소의 시작부분에 두면 운영체제는 사용자 프로그램이 운영체제로 침범하지 않도록 막기만 하면 된다.
- 운영체제의 역할이 단순해서 구현하기 쉽지만 CPU를 효율적으로 사용할 수 없다.

![Untitled](https://user-images.githubusercontent.com/85864699/201537778-aa8dd673-35da-47eb-a64f-c4b6782f13ed.png)

## 다중 프로그래밍

- 메인메모리에 여러개의 작업을 쌓아둔 후, CPU가 작업을 오가며 동시에 실행하는 기법이다.
- 다중 프로그래밍 환경의 메인메모리 관리 기법은 크게 연속메모리 기법과 불연속 메모리 기법으로 나뉜다.
- 연속메모리 기법
    - 고정분할
    - 동적분할
    - 고정분할 메모리 관리는 기성복을 입는 것에 비유를 할 수 있고, 가변 분할 메모리 관리는 맞춤복을 입는 것에 비유할 수 있다.
- 불연속 메모리 기법
    - 프로그램의 일부가 서로 다른 공간에 할당될 수 있는 기법이다.
    - Page: 프로세스들을 고정된 크기의 작은 블록들로 나눴을 때, 그 블록들을 페이지라고 한다.
    - Frame: 페이지 크기와 같은 주 기억장치 메모리 블록이다.
    - Segment: 서로 다른 크기의 논리적 단위

### 1. 고정분할 메모리 관리 (예전에 쓰던 방법)

![Untitled](https://user-images.githubusercontent.com/85864699/201537801-b28b1c6b-02a9-4c60-ab9b-50e5cf7b3a29.png)

- 컴퓨터가 부팅할 때, 분할된 메모리 구조를 유지하다가 프로그램이 실행되면 적당한 위치를 할당하는 방식이다.
- 나눠진 공간은 하나의 작업이 쌓일 수 있는 **일정한 크기**의 기억공간이므로, 다른 프로세스가 침범하지 않도록 보호되어야 한다.
- 이를 위해 상한 주소와 하한 주소 값이 저장된 레지스터를 사용한다.
- 단편화 : 작업량과 분할 공간의 크기가 일치하지 않아 빈 공간이 생기는 것이다.
    - 내부 단편화: 작업물이 분할 공간에 들어가 있지만 **공간의 크기가 커서** 빈 공간이 발생하는 것이다.
    - 외부 단편화 :  분할 공간의 크기가 작업량 보다 작아서 빈 공간이 된 것이다.
    - 아래 사진을 보면 작업 1은 15KB인데 분할 1이 10KB → 분할 공간이 작아서 들어가지 못한다: 외부단편화
    - 작업3은 15KB인데 분할3이 30KB → 분할 공간이 더 커서 공간의 낭비가 발생다한다 : 내부 단편화
    
    ![Untitled](https://user-images.githubusercontent.com/85864699/201537825-b008203d-4e2a-4fb9-b623-87295034f06d.png)
    
- 고정분할 기법은 메모리가 고정된 파티션으로 분할 → 내부 단편화가 발생한다

### 2. 가변 분할 메모리 관리

- 고정 분할 메모리 관리 기법의 단점을 보완하기 위해 등장했다.
- 고정된 분할 공간의 **경계를 없애고 작업량이 맞는 공간을 할당,** 작업이 완료 되면 빈 공간은 다시 모아 관리한다.
- 사용자 프로그램이 실행되면 그때 그때 알맞은 크기로 공간을 분할해 할당하는 것이다.
- 파티션들의 동적 생성 , 자신의 크기와 같은 파티션에 적재한다 → 외부 단편화 발생
    
    ![Untitled](https://user-images.githubusercontent.com/85864699/201537838-cfcdd895-c179-4753-9e47-6fc8e21af7af.png)
    
    - (a) 운영체제만 메모리에 로딩되어 있고, 메인 메모리는 1개의 파티션으로 존재한다.
    - (b) 프로세스 1~4 순서에 맞게 공간을 할당하고 빈공간은 그대로 남아있다.
    - (c) 프로세스3이 종료되면서 15KB 크기의 빈 공간 추가로 발생한다
    - 빈 공간을 1개로 만들기 위해 프로세스들을 재배치 하는 압축 과정을 실행한다. 합쳐진 40KB 공간은 다음에 실행될 프로세스가 사용한다.
- 압축
    - 단편화를 해결할 수 있는 방법이다.
    - 외부 단편들을 한 곳으로 모으는 것이다.
    - 이런 압축이 항상 가능하진 않다.
        - 프로세스들의 재배치가 로딩시에만 일어난다면 압축이 불가능하다.
        - 주소 결속이 실행 시간에 **동적으로 이루어질 수 있는 주소체계**여야 한다. ⇒ 그래야 압축 후에도 해당 프로세스의 재배치 레지스터 값을 수정해서 사용 가능하다.
        - 압축도 메모리 이용하는 것이기에 비용이 든다. → 압축 비용
        - 압축이 필요한 이유 → 메모리 상 연속된 공간에 프로그램을 탑재하기 때문이다.
        

### 3. 분할 메모리 관리

- 빈 공간에 새로운 프로그램을 할당하는 방식이다.
    - 최초 적합 : 프로그램 크기보다 큰 분할 공간 중 **처음 만나는 공간**을 할당한다.
    - 최적 적합: 프로그램 크기보다 큰 공간 중 **가장 작은** 공간을 할당한다.
    - 최악 적합: 프로그램 크기보다 큰 분할 공간 중 **가장 큰** 공간을 할당한다.

## 가상 메모리 관리

![Untitled](https://user-images.githubusercontent.com/85864699/201537850-ae2c07b0-2f2a-477e-aa07-8f8f6c875bf0.png)

- 지금 당장 실행해야하는 부분만 메인메모리에 저장하고 나머지 프로그램은 보조 기억장치에 둔 채 동작하는 방법이다.
- 실행할 프로그램 크기가 메인메모리보다 크거나 개수가 많으면 메인메모리 내 공간이 부족해 프로그램이 제대로 실행되지 못하는 문제 해결하기 위해 개발되었다.
- [장점]
    - 실제 메모리(RAM)보다 더 큰 공간 사용한다.
    - 가상의 주소 사용해 논리적 연속성을 제공한다.
    - 물리 메모리 주소 공간을 몰라도다된다.
- 메모리 단편화의 해결 방법으로 페이징과 세그멘테이션 기법이 있다.

### 페이징 기법

![Untitled](https://user-images.githubusercontent.com/85864699/201537860-f0b4ccb7-b6f6-4c65-a21c-3032f5e96126.png)

- 프로그램을 일정크기로 나누어 페이지를 만들고 **페이지 단위별로 메인메모리에 올려 동작**하는 방식이다.
- 페이징 동작과정
    - 프로세스는 페이지, 물리 메모리는 프레임으로 나누어진다.
    - 페이지 테이블에는 각 페이지 번호와 해당 페이지가 할당된 프레임의 시작 물리 주소를 저장한다.
    - CPU는 프로그램이 설정한대로 연속적인 주소값으로 명령을 내리고 이는 메모리로 가기전에 **각 페이지의 실제 메모리 주소가 저장되어 있는 테이블에서 물리 주소로 변경**한다.
    - 만약 프로세스가 프레임의 정수배보다 살짝 작다면 마지막 프레임은 전부 사용되지 않고 남아버리는 내부 단편화가 발생한다.(페이지가 클수록 내부 단편화 커짐)
- 💡 메인 메모리 상에서 파일은 떨어져 있어도 되는데 프로세스는 왜 붙어 있어야 할까?
    
    ⇒ 로딩되는 프레임의 시작주소를 알고 있으면 물리적으로 떨어져 있어도 논리적으로 붙어있을 수 있다. (페이징 기법이 페이지 번호를 프레임번호로 전환시켜주기 때문)
    

### 세그멘테이션

![Untitled](https://user-images.githubusercontent.com/85864699/201537872-a6ac28d2-31ef-4e26-b3d6-36acfdc9b51d.png)

- 사용자/프로그래머 관점의 메모리 관리 기법이다.
- Segment : 페이지 같은 개념이지만, 프로세스를 논리적 내용을 기반으로 나눠서 메모리에 배치한다.
- 프로세스를 Code, Data, Stack으로 나누는 것 역시 세그멘테이션이다.
- 세그먼트 테이블은 세그먼트 번호와 시작주소(base), 세그먼트 크기(limit)를 엔트리로 가진다.
- 가상 메모리를 사용한다.
- CPU에서 해당 세그먼트 크기를 넘어서는 주소가 들어오면 인터럽트가 발생해서 해당 프로세스 강제 종료된다.

### Paging vs Segmentation

- paging은 고정 크기를 가진다.
- Segmentation은 가변 크기를 가진다.
- paging은 내부 단편화 발생 가능, Segmentation은 외부 단편화 발생가능하다.
- 왜 쓰는 걸까?
    - 메모리 단편화 해결 위함이다.
    - 다중 프로그래밍 시 여러 프로세스 수용하기 위해 주기억장치를 동적분할하는 메모리 관리 기법이 필요하다. 

## 참고자료

컴퓨터시스템 개론(정기철)

[https://inuplace.tistory.com/345](https://inuplace.tistory.com/345)

[https://m.blog.naver.com/rbdi3222/220623825770](https://m.blog.naver.com/rbdi3222/220623825770)

[https://velog.io/@nnnyeong/OS-메모리-단편화-페이징-세그멘테이션](https://velog.io/@nnnyeong/OS-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94-%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98)

[https://steady-coding.tistory.com/524](https://steady-coding.tistory.com/524)
