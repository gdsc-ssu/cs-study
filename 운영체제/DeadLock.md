## DeadLock

### DeadLock(데드락)이란?

두 개 이상의 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태<br />
무한히 다음 자원을 기다리게 되는 상태를 말한다<br />
<img src="https://user-images.githubusercontent.com/21211957/208356314-8ba6c56c-d60b-4c95-839f-675f76f9879d.jpeg" width="500" height="300">
- 스레드 1은 L1을 홀드하고 있는 상태에서 L2의 락이 풀리기를 기다린다.
- 스레드 2는 L2를 홀드하고 있는 상태에서 L1의 락이 풀리기를 기다린다.<br />
  => 서로가 서로를 기다리는 교착상태가 일어난다.

### DeadLock의 발생 이유

주로 멀티 프로그래밍 환경에서 한정된 자원을 사용하려고 서로 경쟁하는 상황에서 발생

- 코드가 길어질수록 발생할 확률이 높아진다
- 모듈화된 함수나 라이브러리를 사용할 때 그 안에서 Lock을 잡는데 사용자가 모를경우에도 발생한다

### DeadLock의 발생 조건

총 4가지의 조건이 있고 **4가지 모두** 만족해야지 데드락이 발생할 수있다

1. Mutual Exclusion (상호배제)
   - 하나의 자원을 동시에 하나의 스레드만 사용가능
2. Hold and Wait (점유와 대기)
   - 스레드가 할당된 자원을 가진 상태에서 다른 자원을 기다림
3. Non Preemptive (비선점)
   - 한 스레드가 자원을 사용하고 있을때 다른 스레드가 강제로 빼았을 수 없음
4. Circular wait (순환 대기)
   - 2번 조건의 스레드들이 순환적으로 다음 스레드가 요구하는 자원을 가지고 있다

### DeadLock을 피하는 방법

#### 1. 예방(Prevention)

데드락 발생 조건 4가지중에서 한가지를 만족하지 못하게 만든다<br />

    1) Mutual Exclusion (상호배제) 조건 방지
        - 자원을 공유하여 상호배제를 없앰
    2) Hold and Wait(점유와 대기) 조건 방지
        - lock을 잡을때 모든 공유자원의 lock을 한번에 잡아서 점유 대기 조건을 없앰
    3) Non Preemptive (비선점) 조건 방지
        - 선점 가능한 스켸줄러 사용
    4) Circular wait (순환 대기) 조건 방지
        - 크리티컬한 자원을 사용할 때 모든 자원을 한번에 lock함

-> 이런식으로 예방하는 방법은 자원의 낭비가 심함 (메모리 등)

#### 2. 회피(Avoidance)

발생 조건 4가지는 유지하지만 다른 방법으로 데드락을 회피<br />
교착 상태 회피는 교착 상태가 발생하기 전에 교착 상태를 예상하여 안전한 상태(safe state)에서만 자원 요청을 허용

- 은행원 알고리즘 (Banker’s algorithm) : 현재 데드락이 발생할 수 있는지 없는지를 판단하여 안전한 상태에서만 자원을 할당<br />

  단, 여러가지 조건을 만족해야지 회피를 할 수 있음.

  - 스레드 수가 고정되어 있어야 한다
  - 자원의 종류와 수가 고정되어 있어야 한다
  - 스레드가 요구하는 자원 및 최대 자원의 수를 알아야 한다
  - 스레드는 반드시 자원을 사용 후 반납해야 한다

#### 3. 발견 및 회복 (Detect and Recover)

데드락이 발생하기 전까지는 냅두다가 발생했을 경우에 원인을 파악하여 고친다.

- 스레드 종료 방법
  - 교착 상태의 스레드 모두 중지
  - 교착 상태가 제거될 때까지 한 스레드씩 중지
- 자원 선점 방법
  - 자원을 빼앗긴 스레드는 강제 종류 이후 재시작
  - 교착 상태에 빠진 스레드가 필요로 하는 자원을 강제로 가져옴
