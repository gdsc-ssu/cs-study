# Transaction

## 트랜잭션

### 트랜잭션이란?

- 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.

### 트랜잭션의 특징

- 데이터베이스 시스템에서 동시성 제어 및 회복 작업 시 처리되는 작업의 논리적 단위
- 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업단위
- 하나의 트랜잭션은 Commit 되거나 Rollback된다.
- 쪼갤 수 없는 업무의 최소 단위 → 대표적으로 거래 내역이 있다

### 트랜잭션의 성질

흔히 ACID라고 부른다. 

1. **Atomicity (원자성)**
- 트랜잭션의 연산은 데이터베이스에 **모두 반영되든지 아니면 전혀 반영되지 않아야 한다.**
- 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두 완벽히 수행되지 않고 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

2. **Consistency (일관성)**
- 트랜잭션이 그 실행을 성공적으로 완료하면 **언제나 일관성있는 데이터베이스 상태로 변환**한다.
- 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 수행 완료 후의 상태가 같아야 한다.

3. **Isolation(독립성)**
- 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 **트랜잭션 실행 중에 다른 트랜잭션 연산이 끼어들 수 없다**
- 수행 중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.

4. **Durability(영속성,지속성)**
- 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 **영구적으로 반영되어야 한다.**

### 트랜잭션 연산 및 상태

기본적으로 All or Nothing을 취한다.

→ 모든 것을 수행하던지 아무것도 하지 말던지 방식으로 DML 명령어들을 처리한다. 

❓ **DML 명령어**

⇒ 데이터 조작하는 명령어. 대표적으로 INSERT, UPDATE, DELETE가 있다. 

**Commit 연산**

![Untitled](https://user-images.githubusercontent.com/85864699/202952753-83cec218-8f3a-440b-b2a3-9fa9c5b83fc3.png)

- 모든 작업들을 정상적으로 처리하겠다고 확정하는 명령어
- 처리 과정을 데이터베이스에 영구적으로 저장
- 커밋 수행 후
    - 하나의 트랜잭션 과정 종료
    - 이전 데이터가 완전히 업데이트 됨

**Rollback연산** 

![Untitled](https://user-images.githubusercontent.com/85864699/202953056-6062fe3d-4817-4ed5-8f00-2bb73b6bde14.png)

- 하나의 트랜잭션 처리가 비정상 종료되어 데이터베이스의 **일관성을 깨뜨렸을 때**, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 연산을 모든 연산을 취소(Undo)하는 연산
- 트랜잭션 시작되기 이전의 상태로 되돌림
    - 마지막 커밋 완료한 시점으로 되돌아감
    - 마지막으로 수행한 커밋 명령까지만 정상 처리된 상태로 유지
    - 커밋하여 저장한것만 복구
- Rollback 시에는 해당 트랜잭션을 재시작하거나 폐기.

**Save point 연산**

![Untitled](https://user-images.githubusercontent.com/85864699/202953102-922d8db5-670f-4746-a6b7-3ec331072c9b.png)

- 임시저장, 부분 저장
- 전체가 아닌 특정 부분에서 트랜잭션을 취소하기 위해 사용
- 현재 트랜잭션에서 작게 분할 가능
- 여러개의 SQL문의 실행을 수행하는 트랜잭션의 경우, 사용자가 트랜잭션 중간 단계에서 지정 가능
- 취소 지점 명시 → 그 지점까지 작업 취소

```sql
SAVEPOINT 세이브포인트 명; // 세이브 포인트 지정
ROLLBACK TO 세이브 포인트 며이 // 해당 세이브 포인트 지점까지 처리한 작업 롤백
```

### 트랜잭션 상태

![Untitled](https://user-images.githubusercontent.com/85864699/202953166-f65bcb83-6e5b-450c-9181-0ff0161a1841.png)

- **활동**
    - 트랜잭션이 실행중인 상태
- **실패**
    - 트랜잭션 실행에 오류가 발생하여 중단된 상태
- **철회**
    - 트랜잭션이 비정상 종료되어 롤백 연산을 수행한 상태
- **부분 완료**
    - 트랜잭션 마지막 연산까지 실행
    - 커밋 연산이 실행되기 직전의 상태
- **완료**
    - 트랜잭션이 성공적으로 종료되어 커밋 연산을 실행한 후의 상태

### 복구

- REDO
    - UNDO로 취소했던 작업을 마음이 바뀌어 다시 되돌리는 작업
    - “취소”를 취소
    - 이미 **커밋한 트랜잭션 수정을 재반영하**는 복구 작업
- UNDO
    - 방금전에 했던 일을 취소
    - 사용자가 했던 작업을 원상태로 복구
    - **트랜잭션이 시작됐지만 커밋 되지 않은** 것을 연산 취소
    - 용도
        - 트랜잭션 롤백 대비용
        - 트랜잭션 격리 수준 유지하면서 높은 동시성 제공

## 데이터베이스에서 동시성문제와  동시성 제어

### **동시성이란 (Concurrency)이란 ?**

- 데이터베이스에서 직렬성은 각각의 트랜잭션이 일정한 순서를 가지고 순차적으로 실행되는 것을 말한다.
- 반대로 동시성은 트랜잭션이 순차적으로 실행되는 것이 아니라 트랜잭션을 구성하는 각각의 쿼리문들이 트랜잭션의 순서에 상관없이 동시에 수행되는 것을 말한다.
- 매우 빠르게 여러 트랜잭션 사이를 이동하면서 조금씩 처리를 수행하는 방식으로 , 실제로 한번에 한 트랜잭션만 수행하지만 마치 동시에 여러 트랜잭션을 수행하는 것 처럼 보이도록 한다.

### 동시성 문제

동시성 제어를 하지 않고 트랜잭션들이 동시에 데이터베이스에 접근할 때 생기는 문제점 을 말한다.

- 갱신손실 (Lost Update)
    - 하나의 트랜잭션이 갱신한 내용을 다른 트랙재션이 덮어씀으로써 갱신이 무효화 되는 것을 의미.
    - 두개이상의 트랜잭션이 한개의 데이터를 동시에 갱신(UPDATE) 할 때 발생.
    
    ![Untitled](https://user-images.githubusercontent.com/85864699/202953227-3e4865e9-48c7-4224-b3f5-373f0cd3b0a2.png)
    
    - 최종적으로는 800이 더해져야 하지만 트랜잭션 1이 갱신하기 이전에 트랜잭션 2가 x값을 받아와서 결국 최종 결과는 +500이 되어버린다.

- 모순성 (Inconsistency)
    - 하나의 트랜잭션이 여러 데이터 갱신 연산을 수행할 때, 일관성 없는 상태의 데이터베이스에서 데이터를 가져옴으로써 데이터 불일치가 발생하는 것
        
        ![Untitled](https://user-images.githubusercontent.com/85864699/202953276-d9ddf048-bb2c-454b-91c9-d20b31782578.png)
        
    - 트랜잭션 1이 완료되기 전에 트랜잭션 2가 수행된 모습이다.
    - 최종적으로 y에 500을 더해준 후 4를 곱한 결과가 나와야 하지만 4를 곱한 y값에 500을 더하는 모습이 발생한다.
    - 트랜잭션 2는 일관성이 유지되지만, 트랜잭션 1은 실행 전 후 차이가 500만큼이 발생해야하는데 그보다 더 한 차이가 발생하기에 데이터 불일치가 발생한다.
- **연쇄복귀 (Cascading Rollback)**
    - 동시에 수행되던 둘 이상 트랜잭션 중 어느 한 트랜잭션에 오류가 발생하여 Rollback하는 경우 다른 트랜잭션들도 함께 Rollback되는 현상을 말한다.
        
        ![Untitled](https://user-images.githubusercontent.com/85864699/202953306-160c9038-f8e0-483f-821a-0acbe724acd6.png)
        
    - 초기값 x=1500, y=1000,과 x를 300 증가시키고 y를 감소시키는 트랜잭션 1과 x를 3배 증가시키는 트랜잭션2가 있다. 트랜잭션1이 x를 300 증가시키고, write하여 1800이 된 상태에서 트랜잭션2가 실행되어 x를 3배하여 write한 후 종료됐다고 가정해보자.
    - 트랜잭션1이 Rollback연산을 하여 x를 1500으로 되돌리려고 하는데 트랜잭션 2는 이미 해당 트랜잭션을 완료하여 종료되었으므로 롤백할 수 없게 되어버리는 문제 발생
- **비완료 의존성 (Uncommitted Dependency)**
    - 하나의 트랜잭션 수행이 실패한 후 회복하기 전에 다른 트랜잭션이 실패한 갱신 결과 참조하는 현상

### 동시성 제어

- **동시성 제어란**
    - 트랜잭션이 병행 수행될 때, 트랜잭션이 데이터베이스의 일관성을 파괴하지 않고, 다른 트랜잭션에 영향을 주지 않도록 트랜잭션 간의 상호작용을 제어하는 것

- **동시성 제어의 목적**
    - 데이터베이스의 일관성 유지
    - 데이터베이스 공유 최대화
    - 시스템 활용도 최대화
    - 사용자 응답시간 최소화
    - 단위 시간 당 트랜잭션 처리 건수 최대화

### 동시성 제어기법

1. **Locking**

→ 트랜잭션이 접근하려는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는 기법

→ 잠금 기법은 기본적으로 lock연산과 unlock연산을 사용한다. 

→ lock의 종류는 공유 lock과 배타 lock이 있다.

![Untitled](https://user-images.githubusercontent.com/85864699/202953360-f06a3e68-c847-4c59-b94e-15675bbf4b11.png)

- 공유 락 (Shared lock)
    - 데이터를 읽을 때 사용되는 lock
    - 공유락 끼리는 동시에 접근 가능 (하나의 데이터를 읽는 것은 여러 사용자가 동시에 가능)
    - 하나의 데이터에 대해 여러개의 공유 락 가능
    - 공유락이 설정된 데이터에 배타락을 사용할 수 없다.
- 배타 락 (Exclusive Lock)
    - 배타 락을 설정한 트랜잭션은 읽기와 쓰기 연산 모두 가능
    - 하나의 데이터 항목에 대해서 하나의 배타 락만 가능
    - 데이터를 변경하고자 할 때 사용
    - 베타락은 lock이 해제될 때까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근 할 수 없다.
    - 다른 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함께 lock 설정 불가능 (동시에 여러개 배타락 불가능)

- **교착상태 (Dead Lock)**
    - 로킹 기법의 문제점
    - 여러 트랜잭션이 특정 데이터에 lock을 한 채 다른 트랜잭션이 lock을 수행한 데이터에 접근하려고 할 때 실행하지 못하고 서로 무한정 기다리는 상태
    - 교착상태에 빠지면 강제로 트랜잭션을 중단하거나 잠금을 해제하지 않는 이상 무한정 대기 상태로 남게 된다.

![Untitled](https://user-images.githubusercontent.com/85864699/202953406-07fffd74-9a1d-404c-a88a-397c677da930.png)

  

- ✏️ **Lock의 설정 범위(Level)**
    - 데이터베이스
        - 전체 데이터베이스를 기준으로 lock을 하는 것
        - DB 소프트웨어 버전을 올리던지, 주요한 DB 업데이트에 사용
    - 테이블
        - 테이블을 기준으로 Lock 설정
        - 전체 테이블에 영향 주는 변경 수행할 때 유용
        - DDL(create,alter,drop 등) 구문과 함께 사용되며 DDL Lock이라고 함
    - 행(Row)
        - 1개의 행을 기준으로 Lock 설정
        - DML에 대한 Lock으로 가장 일반적으로 사용하는 Lock

2. **2단계 로킹 규약** 

→ 하나의 트랜잭션만이 공유 데이터를 사용할 수 있는데, 실제로 오직 읽기만 하는 경우 동시에 접근해도 문제가 없기에 효율적이지 못함. 

→ 뿐만 아니라 직렬 가능한 스케줄이 항상 보장 되지 않아서 2단계 로킹 규약으로 해결 

→ 각 트랜잭션의 lock과 unlock 요청을 2단계로 실시하는 방식 

![Untitled](https://user-images.githubusercontent.com/85864699/202953457-a8f61b9e-308b-4ba6-ad53-76b0967692aa.png)

- 확장 단계: 새로운 lock 연산만 수행할 수 있고, unlock 연산은 수행할 수 없는 단계
- 축소 단계: unlock연산은 수행할 수 있고, lock 연산은 수행할 수 없는 단계
- 트랜잭션 내의 모든 lock연산이 첫번째 unlock 연산 이전에 위치해야한다.
- 한계: 여전히 lock 연산으로 인한 교착 상태 예방 불가능

3. **타임스탬프 순서 기법**
- 트랜잭션을 식별하기 위하여 DBMS 가 부여하는 유일한 식별자인 타임 스탬프를 지정하여 트랜잭션간의 순서를 미리 선택하는 동시성 제어 기법
- Timestamp 순서대로 데이터에 접근하여 lock을 사용하지 않고 시간을 나눠 사용하기에 교착상태 (Dead Lock)이 발생하지 않는다.
- 운영 방식
    - read_TS(x) : read(x) 연산을 성공적으로 수행한 트랜잭션들의 타임스탬프 중 가장 큰 것
    - write_TS(x) : write(x) 연산을 성공적으로 수행한 트랜잭션들의 타임스탬프 중 가장 큰 것

4. **낙관적 병행제어**
    - 트랜잭션 수행동안은 어떠한 검사를 하지 않고, 트랜잭션이 종료된 이후 일괄적으로 검사

5. **다중 버전 병행제어**
- 하나의 데이터에 대해 여러 버전의 값을 유지하며 관리하는 방식

### 트랜잭션 격리 수준

- 특정 트랜잭션이 **다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정**하는 것
- READ UNCOMMITTED이 가장 격리 수준이 낮고, SERIALIZABLE 이 가장 격리 수준이 높다
- 일반적인 온라인 서비스 용도의 DB는 READ COMMITTED와 REPEATABLE READ 를 사용한다.
    - **READ UNCOMMITTED (커밋 되지 않은 읽기)**
        - 각 트랜잭션에서의 변경 내용이 **COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보여진**다.
        - RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많음
        - 문제점 : **“DIRTY READ”**
    
    - **READ COMMITTED (커밋된 읽기)**
        - 온라인 서비스에서 가장 많이 선택되는 격리 수준
        - 더티리드 같은 현상은 발생하지 않음
        - 어떠한 트랜잭션에서 데이터를 변경하더라도 **커밋이 완료된 데이터만 다른 트랜잭션에서 조회 가능**
        - 문제점: ****"NON-REPEATABLE READ"****
        
    - **REPEATABLE READ (반복가능한 읽기)**
        - 트랜잭션 내에서 한 번 조회한 데이터를 반복해서 조회해도 결과는 동일
        - MySQL InnoDB 스토리지 엔진에서 기본적으로 사용되는 격리 수준
        - **"NON-REPEATABLE READ"** 부정합이 발생하지 않음.
        - InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두(Undo) 영역에 백업해두고 실제 레코드 값을 변경 → MVCC 방식이라고 함. (다중 버전 병행수행 제어)
        - **REPEATABLE READ**는 이 MVCC를 위해 **UNDO영역에 백업된 이전 데이터를 통해 동일한 트랜잭션 내에서는 동일한 결과**를 보여줄 수 있도록 보장
        - 문제점 : “**PHANTOM READ”**
    
    - **SERIALIZABLE (직렬화 가능)**
        - 가장 단순한 격리 수준이면서 가장 엄격한 격리 수준
        - 완벽한 읽기 일관성 모드 제공
        - 동시 처리 성능도 다른 트랜잭션 격리 수준 보다 현저히 떨어짐
        - 읽기 작업도 공유잠금을 획득해아함.
        - 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 절대 접근할 수 없음

### 트랜잭션 격리 수준에 따른 바람직하지 않은 읽기 연산

- **DIRTY READ**
    - 어떤 트랜잭션에서 처리한 작업이 완료되지 않았음에도 불구하고 다른 트랙잭션에서 볼 수 있게 되는 현상
    - 어떠한 트랜잭션이 x를 y로 변경했는데 그 다음 트랜잭션이 y를 읽은 상태에서 이전 트랜잭션이 롤백 해버리는 현상
    - Dirty Read가 허용되는 격리 수준이 **READ UNCOMMITTED**
    - 데이터가 나타났다 사라졌다하는 현상을 초래할 수 있음.
- **NON-REPEATABLE READ**
    - 한 트랜잭션 내에서 같은 쿼리를 두번 수행할 때, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리가 상이하게 나타나는 비 일관성이 발생
    - 다른 트랜잭션에서 입금과 출금 처리가 계속 진행되고 있을 때 **다른 트랜잭션에서 오늘 입금된 금액의 총합을 조회**한다고 가정
    - "REPEATABLE READ"가 보장되지 않기 때문에 총합을 계산하는 SELECT 쿼리를 실행할 때마다 다른 결과를 가져올 것
    - 동일한 SELECT 쿼리를 실행했을 때 항상 같은 결과를 보장해야하는 "REPEATABLE READ" 정합성에 어긋나는 현상
- **PHANTOM READ**
    - 한 트랜잭션에서 동일한 쿼리 두번 시행했는데 첫번째 쿼리에서 존재하지 않았던 유령 레코드가 두번째 쿼리에서 나타나는 현상
    - **다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안보였다가 하는 현상**
    - 예를 들어 사용자 A가 INSERT를 실행하는 도중 사용자 B가 동일한 테이블을 UPDATE 쿼리로 조회한다면
    - SELECT .. FOR UPDATE 쿼리는 SELECT 하는 레코드에 쓰기 잠금을 걸어야하는데 UNDO에는 잠금을 걸 수 없음.

## 참고자료

[https://velog.io/@yu-jin-song/DB-트랜잭션Transaction](https://velog.io/@yu-jin-song/DB-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction)

[https://mommoo.tistory.com/62](https://mommoo.tistory.com/62)

[https://untitledtblog.tistory.com/131](https://untitledtblog.tistory.com/131)

[https://coding-factory.tistory.com/226](https://coding-factory.tistory.com/226)

[https://rebro.kr/163](https://rebro.kr/163)

[https://mangkyu.tistory.com/30](https://mangkyu.tistory.com/30)

[https://sabarada.tistory.com/121](https://sabarada.tistory.com/121)

[https://velog.io/@ha0kim/잠금Locking-기법](https://velog.io/@ha0kim/%EC%9E%A0%EA%B8%88Locking-%EA%B8%B0%EB%B2%95)

- 트랜잭션 격리 수준

[https://zzang9ha.tistory.com/381](https://zzang9ha.tistory.com/381)

[http://wiki.gurubee.net/pages/viewpage.action?pageId=21200923](http://wiki.gurubee.net/pages/viewpage.action?pageId=21200923)
